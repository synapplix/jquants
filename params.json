{"name":"Jquants","tagline":"The Java API for Mixed Calculations of Scientific Units and Sums of Money","body":"Jquants \r\n=====\r\n### The Java API for Mixed Calculations of Scientific Units and Sums of Money\r\nJquants addresses the insufficient support for Mixed Calculations of Scientific Units and Sums of Money within Java. The library has been created by translating the Scala library [Squants](https://github.com/garyKeorkunian/squants/) by GaryKeorkun into Java. The outcome is capable of reducing both, the complexity and susceptibility to errors for end-users when dealing with such calculations.\r\n\r\n#### **Jquants provides**: \r\n\r\n- **Type safety**\r\n- Close to full **test coverage** (93,3% - last updated 26.01.2016 and measured with the tool [EclEmma](http://eclemma.com/))\r\n- **All vital quantities for business applications**  (*see Implementation*)\r\n- About the **same performance as its model Squants** (measured with a microbenchmark test using the [Java Microbenchmark Harness tool](http://openjdk.java.net/projects/code-tools/jmh/))\r\n\r\nThe library has emerged within the work on my bachelor thesis conducted at the Technical University Munich (TUM). The thesis has addressed the creation of a solution for \"Mixed Calculations of Scientific Units and Sums of Money in Java\" cooperating with one of the solution-seeking users, the company [Synapplix](http://www.synapplix.de/). \r\nAfter identifying the translation of [Squants](https://github.com/garyKeorkunian/squants/), as the most viable option, the Java library Jquants has been implemented thereof. \r\nFor further information on the analysis of currently existing solutions, Jquants' implementation or the performance test I refer to the latest version of my [bachelor thesis](www.LINK.de) and its [presentation](LINK) .\r\n\r\n\r\n### Current Version ###\r\n\r\nCurrent Version: V 1.0\r\n\r\nModel Squants version: [0.6.1](https://github.com/garyKeorkunian/squants/wiki/Release-History#061-snapshot)\r\n\r\n\r\n### Implementation ###\r\nAll within the project initially specified packages have been translated and tested with their respective unit-tests. \r\nAll quantity values are implemented as type double; Solely Money values are held in BigDecimal.\r\n\r\n|**Package**  |**Quantities**|\r\n|:-------     |:------ |\r\n|**Market**   |Money.scala|\r\n|             |Price.scala|\r\n|             |PricePerArea|\r\n|             |PricePerItem|\r\n|**Mass**     | ~~AreaDensity.scala~~|\r\n|             |~~ChemicalAmount.scala~~|\r\n|             |~~Density.scala~~|\r\n|             |Mass.scala|\r\n|**Motion**   |Acceleration.scala|\r\n|             |AngularVelocity.scala|\r\n|             |Force.scala|\r\n|             |Jerk.scala|\r\n|             |MassFlow.scala|\r\n|             |Momentum.scala|\r\n|             |~~Pressure.scala~~|\r\n|             |~~PressureChange.scala~~|\r\n|             |Velocity.scala|\r\n|             |VolumeFlow.scala|\r\n|             |Yank.scala|\r\n|**Space**    |Angle.scala|\r\n|             |Area.scala|\r\n|             |Length.scala|\r\n|             |SolidAngle.scala|\r\n|             |Volume.scala|\r\n|**Time**     |Frequency.scala|\r\n|             |Time.scala|\r\n|             |TimeDerivative \\& Integral|\r\n|             |TimeSquared.scala|\r\n|**Energy**   |Energy.scala|\r\n|             |EnergyDensity.scala|\r\n|             |Power.scala|\r\n|             |PowerRamp.scala|\r\n|             |SpecificEnergy.scala|\r\n\r\n(**~~crossed out~~** quantities were not included in the initially specified set and are thus seen as optional for implementation.)   \r\n\r\n\r\n### Usage\r\n\r\n\r\nWhen performing operations with different quantities developers often use the type double, which provides no information about the quantity, unit or conversions, ultimately leading to misunderstandings and incorrect operations. Jquants tackles this source of error by ensuring dimensional type safety and dimensional correct type conversions.\r\n\r\nFlawed double example: \r\n\r\nThis examples depicts the mistakes one can easily make when using the type double for quantities:\r\n````java\r\ndouble lengthINcm = 1;        // represents 1 cm\r\ndouble lengthINm = 1;         // represents 1 m\r\ndouble time = 10;             // represents 10 s\r\ndouble sum = lengthINcm + lengthINm + time;     // falsely returns 12\r\n````\r\nDue to the use of double one is able to add quantities of the same dimension with different units (1 cm and 1 m) without any conversion.\r\nFurthermore, the user is able to add quantities of different dimensions (length and time), thus resulting in a useless value.\r\n\r\n#### Dimensional Type safety\r\n\r\n*One may only compare, add or subtract quantities of the same dimensions.*\r\n\r\nTherefore Jquants checks operations at compile time and automatically applies scale and type conversions at run-time: \r\n\r\n````java\r\nLength lengthA = Meters(1.0);         // Length: 1 m\r\nLength lengthB = Centimeters(100);    // Length: 1 cm\r\nLength sum = lengthA.plus(lengthB);   // returns Meters(2)\r\n````\r\n\r\nThis works since meters and centimeters are both units of the dimension Length.\r\n\r\nHowever, if one tries to add two quantities of different dimensions the code does not compile and thus helps prevent mistakes that were easily made with the double example above.\r\n\r\n````java\r\nLength length = Meters(1.0);        // Length 1 m\r\nTime time = Seconds(10.0);          // Time: 10 s\r\nLength sum = length.plus(time);     // Invalid operation - does not compile\r\n````\r\n\r\n\r\n#### Dimensionally Correct Type Conversions\r\n\r\n*One may multiply and divide quantities of different dimensions.*\r\n\r\nDimensionally correct type conversions are a key feature of Jquants. By having defined all valid operations and their resulting dimensions one receives the resulting dimension when multiplying or dividing two quantities of different dimensions:\r\n\r\n````java\r\nTime time = Hours(1.0);               // Time: 1 h\r\nLength distance = Kilometers(120.0);  // Length: 120 km\r\nVelocity speed = distance.div(time);  // returns KilometersPerHour(120)\r\n\r\nTime t1 = Seconds(30.0);    // Time: 30 s\r\nTime t2 = Minutes(1.0);     // Time: 1 m\r\ndouble ratio = t1.div(t2);  // returns double: 0.5\r\n````\r\n\r\n#### Unit Conversions\r\n\r\nQuantity values are based in the units you create them:\r\n\r\n````java\r\nLength lengthA = Meters(1.0);       // Length: 1 m\r\nLength lengthB = Centimeters(1.0);  // Length: 1 cm\r\n`````\r\n\r\n\r\nWhile units are implicitly converted within calculations, one may also explicitly convert quantities into different units:\r\n\r\nConvert quantity into different unit using `in`.\r\n\r\n````java\r\nLength lengthA = Meters(1.0);               // Length: 1 m\r\nLength lengthB = lengthA.in(Centimeters);   // returns Centimeters(100)\r\n````\r\n\r\nExtract a double value converted into a specific unit using `to`.\r\n\r\n````java\r\nLength lengthA = Meters(1.0);               // Length: 1 m\r\ndouble lengthB = lengthA.to(Centimeters);   // returns Double: 100\r\n````\r\n\r\n\r\nMost types also include convenient aliases for the `to` method.\r\n\r\n````java\r\nLength lengthA = Meters(1.0);               // Length: 1 m\r\ndouble lengthB = lengthA.toCentimeters();   // returns Double: 100\r\ndouble lengthC = lengthA.toDecimeters();    // returns Double: 10\r\ndouble lengthD = lengthA.toFeet();          // returns Double: 3.2808333333464565 \r\n````\r\n\r\nRepresent quantities as a String with `toString`:\r\n\r\n````java\r\nLength length = Meters(1.0);    // Length: 1 m\r\nString s = length.toString();   // returns String: \"1 m\"\r\n````\r\n\r\nRepresent quantities as a String converted into a different unit using `toString(<UnitOfMeasure>)`:\r\n\r\n````java\r\nLength length = Meters(1.0);              // Length: 1 m\r\nString s = length.toString(Centimeters);  // returns String: \"100 cm\"\r\n````\r\n\r\n\r\nRepresent quantities in tuples using `toTuple()`.\r\n\r\n`````java\r\nLength length = Meters(1.0);                    // Length: 1 m\r\nPair<Double, String> tuple = length.toTuple();  // returns Tuple: [1.0,m]\r\n````\r\n\r\n#### Mapping over Quantity values\r\n\r\nApply a `Double => Double` function to alter the value of a quantity while preserving its type and unit.\r\n\r\n````java\r\nLength length = Meters(1.0);      // Length: 1 m\r\nLength mappedLength = length.map(n -> n.multiply(2).plus(Meters(1)));   // returns Meters: 3 m\r\n````\r\n\r\n#### Approximations\r\n\r\nApproximate whether values lay within a specified tolerance from a quantity using `approx`.\r\n\r\n````java\r\nLength lengthApprox = Meters(1.998);\r\nboolean result = lengthApprox.approx(Meters(2), Meters(0.003));     // returns true\r\n````\r\n\r\n#### Market Package\r\n\r\nThe market package comprises different means of dealing with money. The primary type, Money, is a Dimensional Quantity, and its Units of Measure are Currencies.\r\n\r\n##### Money\r\nA Quantity of purchasing power measured in Currency units.\r\n````java\r\nMoney tenBucks = USD(10.0);       // Money: 10 USD\r\nMoney someYen = JPY(1200);        // Money: 1200 JPY\r\nMoney goldStash = XAU(50);        // Money: 50 XAU\r\nMoney digitalCache = BTC(50);     // Money: 50 BTC\r\n````\r\n\r\n##### Price<Quantity>\r\nA Ratio between Money and another Quantity. A Price value is typed on a Quantity and can be denominated in any defined Currency.\r\n\r\n*Price = Money / Quantity*\r\n\r\nJquants further offers the types *PricePerArea* and *PricePerItem* as being often required in business applications:\r\n\r\n- PricePerArea \r\n````java\r\nArea area = SquareMeters(100.0);      // Area: 100 m²\r\nMoney price = EUR(1000.0);            // Money: 1000 €\r\nPricePerArea rent = price.div(area);  // returns PricePerArea: 1000.00 EUR/100.0 m²\r\n````\r\n\r\n- PricePerItem\r\n````java\r\nDimensionless items = Each(10.0)      // Dimensionless: 10 ea\r\nMoney price = USD(100.0);             // Money: 1000 $\r\nPricePerItem pricePerProduct = price.div(items); // returns PricePerItem: 10 $ / 1.0 ea\r\n````\r\n\r\n#### QuantityRanges\r\n\r\nQuantityRanges are used to represent a range of Quantity values between an upper an lower bound.\r\n\r\n````java\r\nTime time1 = Seconds(1.0);     // Time: 1 s \r\nTime time2 = Seconds(4.0);     // Time: 4 s \r\nQuantityRange<Time> range = time1.to(time2);  // returns Range: 1.0 s to 4.0 s\r\n ````\r\nThese QuantityRanges can be used or altered by a set of methods (`contains, dec, decFrom, decFromIncTo, decTo, divide, foldLeft, foldRight, foreach, inc, incFrom, incFromDecTo,\r\nincludes, includes, incTo, map, partiallyContains, partiallyIncludes, times, toList, toQuantity, toSeq, toString`).\r\n\r\n\r\nApply methods to ranges by using `foreach`, `map`, `foldLeft`, or `foldRight`:\r\n\r\n````java\r\nQuantityRange<Length> range = new QuantityRange(Meters(0), Meters(5));        // QuantityRange: 1.0 s to 4.0 s\r\nrange.foreach(Meters(2.5), r -> System.out.print(\"(\"+r.lower.in(Centimeters)+\",\"+r.upper.in(Centimeters)+\")\")); //returns (0.0 cm, 250.0 cm)(250.0 cm,500.0 cm)\r\nArrayList<?> mapped = range.map(2, x -> x);                       // returns [0.0 m to 2.5 m, 2.5 m to 5.0 m]\r\nLength foldLeft = range.foldLeft(Meters(1), Meters(0),(z, x) -> z.plus(x.upper));   // returns Length: 15.0 m\r\n````\r\n\r\n\r\n### Possible Extensions \r\n\r\nThe following Squants-packages embody possible extensions: \r\n- Electro\r\n- Photo\r\n- Radio\r\n- Storage\r\n\r\n\r\n### Installation ###\r\n\r\n-\r\n-\r\n\r\n### Contributors ###\r\n\r\n  • Mathias Bräu (@mbraeu)\r\n  • Florian Pahl (@johnpaul2)","google":"UA-73730847-1","note":"Don't delete this file! It's used internally to help with page regeneration."}